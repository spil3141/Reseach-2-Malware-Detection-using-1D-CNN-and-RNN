"""
This Code is used to convert APK files to discriminating Images.
owner: spil3141
"""
from androguard.core.bytecodes.apk import APK
from androguard.core.bytecodes.dvm import DalvikVMFormat
import os
import sys
import math
import numpy as np
from PIL import Image
from androguard.misc import AnalyzeAPK

#import timeit
#import multiprocessing
#import PIL
"""############################# Paths to Important Directories ###########################################"""

path_to_mal_apks_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/FInal Full Evaluation/Malware Apks"
#path_to_mal_img_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/Malware Imgs"

path_to_benign_apks_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/FInal Full Evaluation/Benign Apks"
#path_to_benign_img_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/Benign Imgs"

path_to_mal_img_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/FInal Full Evaluation/Dex/Malware Imgs"
path_to_benign_img_dir = "G:/Complete_Dataset/Raw Apk Files/Sorted/FInal Full Evaluation/Dex/Benign Imgs"


"""############################# Conversion Functions ###########################################"""
def From_apk_to_code_item_str(path_of_apk):
    apk = path_of_apk
    apk_obj = APK(apk)
    dalvik_obj = DalvikVMFormat(apk_obj)
    code_item = dalvik_obj.get_codes_item()
    code_item_str = code_item.show() #Required manuel modification of package .show()
    return code_item_str

def From_Code_Item_Str_to_NumpyArray(a1_str):
    a1 = int(a1_str,16)
    a1 = a1.to_bytes(a1.bit_length(), sys.byteorder)
    data_arr = []
    for i in a1:
        data_arr.append(i)
    sample = np.asarray(data_arr)
    return sample

def From_code_item_hex_str_to_tobytes(a1_str,mode = 1):
    if mode == 0:
        #Converting from int to byte
        a1 = int(a1_str,16)
        tobytes = a1.to_bytes(a1.bit_length(),sys.byteorder)
    elif mode == 1:
        #Converting from hex_str to bytes
        tobytes = bytes.fromhex(a1_str)
    return tobytes

def Linear_Plotting(size,data,mode=1):
    if mode == 0:
        img = np.zeros(shape=(size),dtype=np.int)
        count = 0
        for i in range(img.shape[0]):
            for j in range(img.shape[1]):
                if not count >= len(data):
                    img[i,j] = data[count]
                else:
                    img[i,j] = 0
                count += 1
    elif mode ==1 :
        #Method 2: PIL.Image bytes to image Conversion algorithm
        img = Image.frombytes("L",size, data)
    return img

def From_Apk_to_Dex_file_bytes(path_of_apk, mode = 1):
    if mode ==1:
        apk = path_of_apk
        a,d,dx = AnalyzeAPK(apk)
        tobytes = d[0].get_buff()
        tobytes = bytes(tobytes)
    elif mode == 0:
        apk = path_of_apk
        apk_obj = APK(apk)
        dalvik_obj = DalvikVMFormat(apk_obj)
        tobytes = dalvik_obj.get_buff()
        tobytes = bytes(tobytes)
    return tobytes

def HilbertCurve_Plotting(data):
    #Method 1: Hilbert Curve Algorithm
#    print("starting HCA")
#    m = int(math.log2(math.sqrt(len(tobytes))))
#    img1 = np.zeros(shape=(2**m,2**m),dtype=np.int)
#    for d in range ( 0,len(tobytes)):
#        x, y = HilbertCurveAlgorithm.d2xy ( m, d )
#        img1[x,y] = tobytes[d]
    pass




"""########################################################################"""
def mal_code_item_str_2_img_saved():
    cnt = 0 #This keep track of the amoung of error during conversion
    file_w8_error = []
    print("--- Start ---")
    for apk_file in os.listdir(path_to_mal_apks_dir):
        print("---")
        try:
            """################  Code Item Section  ##################"""
#            code_item_str = From_apk_to_code_item_str(os.path.join(path_to_mal_apks_dir,apk_file))
#            tobytes = From_code_item_hex_str_to_tobytes(code_item_str)

            """################  DEX FILE  ##################"""
            tobytes = From_Apk_to_Dex_file_bytes(os.path.join(path_to_mal_apks_dir,apk_file))

            """###############  Linear Plotting of bytes ########"""
            photo_image = Linear_Plotting((int(math.sqrt(len(tobytes))),
                                           int(math.sqrt(len(tobytes)))),tobytes,mode=1)
            
            
            """################  Saving Generated Image ##################"""
            print("Length of code_item_str: ", len(tobytes))
            print("Name of app: ", apk_file)
            img_name = apk_file.split('.')[:-1]
            img_name = "".join([i for i in img_name])
            img_name = img_name + '.png'
            print("Image Name:",img_name)
            photo_image.save(os.path.join(path_to_mal_img_dir,img_name))
            print("--- Good Save ---")
        except:
            cnt += 1
            file_w8_error.append(apk_file)
            print("--- Error while converting---")
            pass

    #Progress notice
    print("Number of Errors: ", cnt)
    print("files with error: ", file_w8_error)

    #Save list of invalid apks into a text file
    with open(os.path.join(path_to_mal_img_dir,"Error_Log(Files_dat_cant_be_converted).txt"),"w+") as file:
        file.write("\n".join([ i for i in file_w8_error]))
    print("--- Malware Conversion Ended ---")


def benign_code_item_str_2_img_saved():
    cnt = 0 #This keep track of the amoung of error during conversion
    file_w8_error = []
    print("---Start ---")
    for apk_file in os.listdir(path_to_benign_apks_dir):
        print("---")
        try:
            """################  Code Item Section  ##################"""
#            code_item_str = From_apk_to_code_item_str(os.path.join(path_to_benign_apks_dir,apk_file))
#            tobytes = From_code_item_hex_str_to_tobytes(code_item_str)

            """################  DEX FILE  ##################"""
            tobytes = From_Apk_to_Dex_file_bytes(os.path.join(path_to_benign_apks_dir,apk_file))

            """###############  Linear Plotting of bytes ########"""
            photo_image = Linear_Plotting((int(math.sqrt(len(tobytes))),
                                           int(math.sqrt(len(tobytes)))),tobytes,mode=1)

            """################  Saving Generated Image ##################"""
            img_name = apk_file.split('.')[:-1]
            img_name = "".join([i for i in img_name])
            img_name = img_name + '.png'
            print("Image Name:",img_name)
            photo_image.save(os.path.join(path_to_benign_img_dir,img_name))
            print("---Good Save ---")
        except:
            cnt += 1
            file_w8_error.append(apk_file)
            print("--- Error ---")
            pass

    #Progress notice
    print("Number of Errors: ", cnt)
    print("files with error: ", file_w8_error)

    #Save list of invalid apks into a text file
    with open(os.path.join(path_to_benign_img_dir,"Error_Log(Files_dat_cant_be_converted).txt"),"w+") as file:
        file.write("\n".join([ i for i in file_w8_error]))
    print("--- Benign Conversion Ended ---")


def run():
#    benign_code_item_str_2_img_saved()
    mal_code_item_str_2_img_saved()

if __name__ == "__main__":
   run()













""" JUNK CODE """


"""

#            binary = int(code_item_str, 16)
#            size = int(((len(binary.to_bytes(int(len(code_item_str)/2), 'big')) // 8)))
#            size = int(math.sqrt(size))
#            photo_image = PIL.Image.frombytes('P', (size,size), binary.to_bytes(int(len(code_item_str)/2), sys.byteorder))
#            ############### method 2 #######################################
#            binary = int(code_item_str,16)
#            size = int(((len(binary.to_bytes(int(len(code_item_str)), sys.byteorder)))))
#            size = int(math.sqrt(size))
#            size_of_img = (150,150)
#            img = PIL.Image.frombytes('P', (size,size), binary.to_bytes(int(len(code_item_str)), sys.byteorder))
#################################################################
# photo_image = PIL.Image.frombytes('P', size_of_img, binary.to_bytes(int(len(code_item_str)/2), "big"))
#            print("Original Image Size: ", (size,size))
#            size_of_img = (150,150)
#            photo_image = photo_image.resize(size_of_img,PIL.Image.ANTIALIAS)
#            print("After Resize: ",photo_image.size)

################  method 2 ##################
#         Downside to this method is that by automatically determining the size of the generated image from the len of
#         the code_item_str we get a diversed size of images.
#     binary = int(code_item_str, 16) #convert code_item_str to int ; code_item_str is taken as a hexadecimal input value.
#        Convert the str to Byte with size of half the original str size;Then for every 8;
#        Divided the byte variable length by 8 to assign each pixel 8 bytes.
# size = int(((len(binary.to_bytes(int(len(code_item_str)/2), 'big')) // 8)))
# size = int(math.sqrt(size))
#    print("Size: ",size)
#    photo_image = PIL.Image.frombytes('L', (size, size), binary.to_bytes(int(len(code_item_str)/2), 'big'))



#            ################  method 1 ##################
#            binary = int(code_item_str, 16)
#            size = int(((len(binary.to_bytes(int(len(code_item_str)/2), 'big')) // 8)))
#            size = int(math.sqrt(size))
#            size_of_img = (150,150)
#            photo_image = PIL.Image.frombytes('P', (size,size), binary.to_bytes(int(len(code_item_str)/2), sys.byteorder))
#            #############################################
#            # photo_image = PIL.Image.frombytes('P', size_of_img, binary.to_bytes(int(len(code_item_str)/2), "big"))
#            print("Original Image Size: ", (size,size))
#            photo_image = photo_image.resize(size_of_img,PIL.Image.ANTIALIAS)
#            print("After Resize: ",photo_image.size)

            ################  method 2 ##################
            #         Downside to this method is that by automatically determining the size of the generated image from the len of
            #         the code_item_str we get a diversed size of images.
            #     binary = int(code_item_str, 16) #convert code_item_str to int ; code_item_str is taken as a hexadecimal input value.
            #        Convert the str to Byte with size of half the original str size;Then for every 8;
            #        Divided the byte variable length by 8 to assign each pixel 8 bytes.
               # size = int(((len(binary.to_bytes(int(len(code_item_str)/2), 'big')) // 8)))
               # size = int(math.sqrt(size))
            #    print("Size: ",size)
            #    photo_image = PIL.Image.frombytes('L', (size, size), binary.to_bytes(int(len(code_item_str)/2), 'big'))





"""
